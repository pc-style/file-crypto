package main

import (
	"encoding/base64"
	"flag"
	"fmt"
	"os"
	"strings"
)

func main() {
	var (
		publicPath    string
		privatePath   string
		decryptorPath string
		policyPath    string
		outPath       string
	)

	flag.StringVar(&publicPath, "public", "", "path to public key (DER or base64)")
	flag.StringVar(&privatePath, "private", "", "path to private key PEM")
	flag.StringVar(&decryptorPath, "decryptor", "", "path to decryptor binary")
	flag.StringVar(&policyPath, "policy", "", "path to policy YAML")
	flag.StringVar(&outPath, "out", "", "output Go file path")
	flag.Parse()

	if publicPath == "" || privatePath == "" || decryptorPath == "" || policyPath == "" || outPath == "" {
		fmt.Fprintln(os.Stderr, "all of -public, -private, -decryptor, -policy, and -out are required")
		os.Exit(1)
	}

	pubB64, err := readBase64(publicPath)
	if err != nil {
		exitErr("read public key", err)
	}

	privB64, err := encodeFile(privatePath)
	if err != nil {
		exitErr("encode private key", err)
	}

	decryptorB64, err := encodeFile(decryptorPath)
	if err != nil {
		exitErr("encode decryptor", err)
	}

	policyB64, err := encodeFile(policyPath)
	if err != nil {
		exitErr("encode policy", err)
	}

	content := fmt.Sprintf(template, pubB64, privB64, decryptorB64, policyB64)
	if err := os.WriteFile(outPath, []byte(content), 0o644); err != nil {
		exitErr("write output", err)
	}
}

func readBase64(path string) (string, error) {
	data, err := os.ReadFile(path)
	if err != nil {
		return "", err
	}
	trimmed := strings.TrimSpace(string(data))
	if trimmed == "" {
		return "", fmt.Errorf("file %s is empty", path)
	}

	if _, err := base64.StdEncoding.DecodeString(trimmed); err == nil {
		return trimmed, nil
	}

	return encodeData(data), nil
}

func encodeFile(path string) (string, error) {
	data, err := os.ReadFile(path)
	if err != nil {
		return "", err
	}
	if len(data) == 0 {
		return "", fmt.Errorf("file %s is empty", path)
	}
	return encodeData(data), nil
}

func encodeData(data []byte) string {
	encoded := base64.StdEncoding.EncodeToString(data)
	return strings.TrimSpace(encoded)
}

func exitErr(action string, err error) {
	fmt.Fprintf(os.Stderr, "%s: %v\n", action, err)
	os.Exit(1)
}

const template = `// Code generated by make build-ransom-sim. DO NOT EDIT.
//go:build simassets

package sim

import (
	"file-crypto/internal/crypto"
	"file-crypto/pkg/config"
	"file-crypto/pkg/policy"
)

func init() {
	crypto.EmbeddedPublicKeyBase64 = "%s"
	crypto.EmbeddedPrivateKeyBase64 = "%s"
	EmbeddedDecryptorBase64 = "%s"
	policy.EmbeddedPolicyYAML = "%s"
	config.DefaultSimulationModeStr = "true"
	config.DefaultPolicyPathStr = ""
}
`
